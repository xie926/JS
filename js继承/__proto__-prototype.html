<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
</head>

<body>
  <script>
    function Person() {
      this.age = 40
    }
    Person.prototype.say = function () {

    }
    console.log(Person.prototype)
    // Object
    var obj = {}
    obj.hasOwnProperty('b')
    console.log(obj.__proto__ === Object.prototype)

    var p = new Person();
    /*
    {
      __proto__: {
        // .prototype
        __proto__: {
          // Object
          __proto__: null
        }
      }
    }
    */
    console.log(p.say)
    console.log(p.__proto__)

    // 继承创建
    // 第一种方法
    function Student() {

    }
    p.__proto__ === Person.prototype  // 结果为true
    Student.prototype = new Person()
    Student.prototype.__proto__ = Person.prototype  // 这种方式易于理解，但不常用

    // 第二种方法
    // 2 浅复制
    Object.create();
    function Student() { }
    Student1.prototype = Object.create(Person.prototype)
    console.log(new Student1());
    // 强调继承方法，不管属性
    // Student1.prototype.__proto__  -> F
    function myCreate() {
      var F = function () { }
      F.prototype = obj;
      return new F();
    }

    // 第三种方法 es6 extends 使用的方法
    function Student3() {
      // 1.继承属性
      // this.age = 30
      Person.call(this);
    }
    // 2. 继承方法
    Student3.prototype = Object.create(Person.prototype)
    // 
    Student.prototype.constructor = Student3;

  </script>
</body>

</html>